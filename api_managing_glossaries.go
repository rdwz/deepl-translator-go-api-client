/*
DeepL API

The DeepL API provides programmatic access to DeepLâ€™s machine translation technology.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ManagingGlossariesApiService ManagingGlossariesApi service
type ManagingGlossariesApiService service

type ApiCreateGlossaryRequest struct {
	ctx context.Context
	ApiService *ManagingGlossariesApiService
	name *string
	sourceLang *GlossarySourceLanguage
	targetLang *GlossaryTargetLanguage
	entries *string
	entriesFormat *string
}

// Name to be associated with the glossary.
func (r ApiCreateGlossaryRequest) Name(name string) ApiCreateGlossaryRequest {
	r.name = &name
	return r
}

func (r ApiCreateGlossaryRequest) SourceLang(sourceLang GlossarySourceLanguage) ApiCreateGlossaryRequest {
	r.sourceLang = &sourceLang
	return r
}

func (r ApiCreateGlossaryRequest) TargetLang(targetLang GlossaryTargetLanguage) ApiCreateGlossaryRequest {
	r.targetLang = &targetLang
	return r
}

// The entries of the glossary. The entries have to be specified in the format provided by the &#x60;entries_format&#x60; parameter.
func (r ApiCreateGlossaryRequest) Entries(entries string) ApiCreateGlossaryRequest {
	r.entries = &entries
	return r
}

// The format in which the glossary entries are provided. Formats currently available: * &#x60;tsv&#x60; - Tab-separated values. Entries have to be specified as tab-separated values with the \\\&quot;source entry\\\&quot; being the text in the source language of the glossary and the \\\&quot;target entry\\\&quot; being the text in the target language of the glossary.    In addition the following restrictions apply:     * Duplicate source entries are not allowed.     * Source-target entry pairs are separated by a newline.     * Source entries and target entries are separated by a tab.     * Source entries and target entries are not empty.     * Source and target entries must not contain any [C0 or C1 control characters](https://en.wikipedia.org/wiki/C0_and_C1_control_codes) (including e.g. &#x60;\\\&quot;\\\\t\\\&quot;&#x60; or &#x60;\\\&quot;\\\\n\\\&quot;&#x60;) or any [Unicode newline](https://en.wikipedia.org/wiki/Newline#Unicode).     * Source and target entries must not contain any leading or trailing Unicode whitespace.    Valid glossary entries in the TSV format could be created in a programming language with backslash escape sequences (e.g. Python, JavaScript, etc.) like this:    &#x60;\\\&quot;sourceEntry1\\\\ttargetEntry1\\\\nsourceEntry2\\\\targetEntry2\\\&quot;&#x60;
func (r ApiCreateGlossaryRequest) EntriesFormat(entriesFormat string) ApiCreateGlossaryRequest {
	r.entriesFormat = &entriesFormat
	return r
}

func (r ApiCreateGlossaryRequest) Execute() (*Glossary, *http.Response, error) {
	return r.ApiService.CreateGlossaryExecute(r)
}

/*
CreateGlossary Create a Glossary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGlossaryRequest
*/
func (a *ManagingGlossariesApiService) CreateGlossary(ctx context.Context) ApiCreateGlossaryRequest {
	return ApiCreateGlossaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Glossary
func (a *ManagingGlossariesApiService) CreateGlossaryExecute(r ApiCreateGlossaryRequest) (*Glossary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Glossary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagingGlossariesApiService.CreateGlossary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/glossaries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.sourceLang == nil {
		return localVarReturnValue, nil, reportError("sourceLang is required and must be specified")
	}
	if r.targetLang == nil {
		return localVarReturnValue, nil, reportError("targetLang is required and must be specified")
	}
	if r.entries == nil {
		return localVarReturnValue, nil, reportError("entries is required and must be specified")
	}
	if r.entriesFormat == nil {
		return localVarReturnValue, nil, reportError("entriesFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(*r.name, ""))
	localVarFormParams.Add("source_lang", parameterToString(*r.sourceLang, ""))
	localVarFormParams.Add("target_lang", parameterToString(*r.targetLang, ""))
	localVarFormParams.Add("entries", parameterToString(*r.entries, ""))
	localVarFormParams.Add("entries_format", parameterToString(*r.entriesFormat, ""))
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["auth_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ListGlossaryLanguages400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteGlossaryRequest struct {
	ctx context.Context
	ApiService *ManagingGlossariesApiService
	glossaryId string
}

func (r ApiDeleteGlossaryRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteGlossaryExecute(r)
}

/*
DeleteGlossary Delete a Glossary

Deletes the specified glossary.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param glossaryId A unique ID assigned to the glossary.
 @return ApiDeleteGlossaryRequest
*/
func (a *ManagingGlossariesApiService) DeleteGlossary(ctx context.Context, glossaryId string) ApiDeleteGlossaryRequest {
	return ApiDeleteGlossaryRequest{
		ApiService: a,
		ctx: ctx,
		glossaryId: glossaryId,
	}
}

// Execute executes the request
func (a *ManagingGlossariesApiService) DeleteGlossaryExecute(r ApiDeleteGlossaryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagingGlossariesApiService.DeleteGlossary")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/glossaries/{glossary_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"glossary_id"+"}", url.PathEscape(parameterToString(r.glossaryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["auth_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ListGlossaryLanguages400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetGlossaryRequest struct {
	ctx context.Context
	ApiService *ManagingGlossariesApiService
	glossaryId string
}

func (r ApiGetGlossaryRequest) Execute() (*Glossary, *http.Response, error) {
	return r.ApiService.GetGlossaryExecute(r)
}

/*
GetGlossary Retrieve Glossary Details

Retrieve meta information for a single glossary, omitting the glossary entries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param glossaryId A unique ID assigned to the glossary.
 @return ApiGetGlossaryRequest
*/
func (a *ManagingGlossariesApiService) GetGlossary(ctx context.Context, glossaryId string) ApiGetGlossaryRequest {
	return ApiGetGlossaryRequest{
		ApiService: a,
		ctx: ctx,
		glossaryId: glossaryId,
	}
}

// Execute executes the request
//  @return Glossary
func (a *ManagingGlossariesApiService) GetGlossaryExecute(r ApiGetGlossaryRequest) (*Glossary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Glossary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagingGlossariesApiService.GetGlossary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/glossaries/{glossary_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"glossary_id"+"}", url.PathEscape(parameterToString(r.glossaryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["auth_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ListGlossaryLanguages400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGlossaryEntriesRequest struct {
	ctx context.Context
	ApiService *ManagingGlossariesApiService
	glossaryId string
	accept *string
}

// The requested format of the returned glossary entries. Currently, supports only &#x60;text/tab-separated-values&#x60;.
func (r ApiGetGlossaryEntriesRequest) Accept(accept string) ApiGetGlossaryEntriesRequest {
	r.accept = &accept
	return r
}

func (r ApiGetGlossaryEntriesRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetGlossaryEntriesExecute(r)
}

/*
GetGlossaryEntries Retrieve Glossary Entries

List the entries of a single glossary in the format specified by the `Accept` header.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param glossaryId A unique ID assigned to the glossary.
 @return ApiGetGlossaryEntriesRequest
*/
func (a *ManagingGlossariesApiService) GetGlossaryEntries(ctx context.Context, glossaryId string) ApiGetGlossaryEntriesRequest {
	return ApiGetGlossaryEntriesRequest{
		ApiService: a,
		ctx: ctx,
		glossaryId: glossaryId,
	}
}

// Execute executes the request
func (a *ManagingGlossariesApiService) GetGlossaryEntriesExecute(r ApiGetGlossaryEntriesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagingGlossariesApiService.GetGlossaryEntries")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/glossaries/{glossary_id}/entries"
	localVarPath = strings.Replace(localVarPath, "{"+"glossary_id"+"}", url.PathEscape(parameterToString(r.glossaryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/tab-separated-values", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		localVarHeaderParams["Accept"] = parameterToString(*r.accept, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["auth_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ListGlossaryLanguages400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListGlossariesRequest struct {
	ctx context.Context
	ApiService *ManagingGlossariesApiService
}

func (r ApiListGlossariesRequest) Execute() (*ListGlossaries200Response, *http.Response, error) {
	return r.ApiService.ListGlossariesExecute(r)
}

/*
ListGlossaries List all Glossaries

List all glossaries and their meta-information, but not the glossary entries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListGlossariesRequest
*/
func (a *ManagingGlossariesApiService) ListGlossaries(ctx context.Context) ApiListGlossariesRequest {
	return ApiListGlossariesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListGlossaries200Response
func (a *ManagingGlossariesApiService) ListGlossariesExecute(r ApiListGlossariesRequest) (*ListGlossaries200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListGlossaries200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagingGlossariesApiService.ListGlossaries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/glossaries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["auth_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ListGlossaryLanguages400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGlossaryLanguagesRequest struct {
	ctx context.Context
	ApiService *ManagingGlossariesApiService
}

func (r ApiListGlossaryLanguagesRequest) Execute() (*ListGlossaryLanguages200Response, *http.Response, error) {
	return r.ApiService.ListGlossaryLanguagesExecute(r)
}

/*
ListGlossaryLanguages List Language Pairs Supported by Glossaries

Retrieve the list of language pairs supported by the glossary feature.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListGlossaryLanguagesRequest
*/
func (a *ManagingGlossariesApiService) ListGlossaryLanguages(ctx context.Context) ApiListGlossaryLanguagesRequest {
	return ApiListGlossaryLanguagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListGlossaryLanguages200Response
func (a *ManagingGlossariesApiService) ListGlossaryLanguagesExecute(r ApiListGlossaryLanguagesRequest) (*ListGlossaryLanguages200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListGlossaryLanguages200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagingGlossariesApiService.ListGlossaryLanguages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/glossary-language-pairs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["auth_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ListGlossaryLanguages400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
