/*
DeepL API

The DeepL API provides programmatic access to DeepLâ€™s machine translation technology.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// TranslatingDocumentsApiService TranslatingDocumentsApi service
type TranslatingDocumentsApiService service

type ApiDownloadDocumentRequest struct {
	ctx context.Context
	ApiService *TranslatingDocumentsApiService
	documentId string
	getDocumentStatusRequest *GetDocumentStatusRequest
}

func (r ApiDownloadDocumentRequest) GetDocumentStatusRequest(getDocumentStatusRequest GetDocumentStatusRequest) ApiDownloadDocumentRequest {
	r.getDocumentStatusRequest = &getDocumentStatusRequest
	return r
}

func (r ApiDownloadDocumentRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.DownloadDocumentExecute(r)
}

/*
DownloadDocument Download Translated Document

Once the status of the document translation process is `done`, the result can be downloaded.


For privacy reasons the translated document is automatically removed from the server once it was downloaded and cannot be downloaded again.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param documentId The document ID that was sent to the client when the document was uploaded to the API.
 @return ApiDownloadDocumentRequest
*/
func (a *TranslatingDocumentsApiService) DownloadDocument(ctx context.Context, documentId string) ApiDownloadDocumentRequest {
	return ApiDownloadDocumentRequest{
		ApiService: a,
		ctx: ctx,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *TranslatingDocumentsApiService) DownloadDocumentExecute(r ApiDownloadDocumentRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslatingDocumentsApiService.DownloadDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/document/{document_id}/result"
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterToString(r.documentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getDocumentStatusRequest == nil {
		return localVarReturnValue, nil, reportError("getDocumentStatusRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getDocumentStatusRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["auth_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v DocumentTranslationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v DocumentTranslationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDocumentStatusRequest struct {
	ctx context.Context
	ApiService *TranslatingDocumentsApiService
	documentId string
	getDocumentStatusRequest *GetDocumentStatusRequest
}

func (r ApiGetDocumentStatusRequest) GetDocumentStatusRequest(getDocumentStatusRequest GetDocumentStatusRequest) ApiGetDocumentStatusRequest {
	r.getDocumentStatusRequest = &getDocumentStatusRequest
	return r
}

func (r ApiGetDocumentStatusRequest) Execute() (*GetDocumentStatus200Response, *http.Response, error) {
	return r.ApiService.GetDocumentStatusExecute(r)
}

/*
GetDocumentStatus Check Document Status

Retrieve the current status of a document translation process.
If the translation is still in progress, the estimated time remaining is also included in the response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param documentId The document ID that was sent to the client when the document was uploaded to the API.
 @return ApiGetDocumentStatusRequest
*/
func (a *TranslatingDocumentsApiService) GetDocumentStatus(ctx context.Context, documentId string) ApiGetDocumentStatusRequest {
	return ApiGetDocumentStatusRequest{
		ApiService: a,
		ctx: ctx,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return GetDocumentStatus200Response
func (a *TranslatingDocumentsApiService) GetDocumentStatusExecute(r ApiGetDocumentStatusRequest) (*GetDocumentStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDocumentStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslatingDocumentsApiService.GetDocumentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/document/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterToString(r.documentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getDocumentStatusRequest == nil {
		return localVarReturnValue, nil, reportError("getDocumentStatusRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getDocumentStatusRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["auth_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateDocumentRequest struct {
	ctx context.Context
	ApiService *TranslatingDocumentsApiService
	targetLang *TargetLanguage
	file **os.File
	sourceLang *SourceLanguage
	filename *string
	formality *Formality
	glossaryId *string
}

func (r ApiTranslateDocumentRequest) TargetLang(targetLang TargetLanguage) ApiTranslateDocumentRequest {
	r.targetLang = &targetLang
	return r
}

// The document file to be translated. The file name should be included in this part&#39;s content disposition. As an alternative, the filename parameter can be used. The following file types and extensions are supported:   * &#x60;docx&#x60; - Microsoft Word Document   * &#x60;pptx&#x60; - Microsoft PowerPoint Document   * &#x60;pdf&#x60; - Portable Document Format   * &#x60;htm / html&#x60; - HTML Document   * &#x60;txt&#x60; - Plain Text Document  Please note that in order to translate PDF documents you need to give one-time consent to using the Adobe API via the account interface.
func (r ApiTranslateDocumentRequest) File(file *os.File) ApiTranslateDocumentRequest {
	r.file = &file
	return r
}

func (r ApiTranslateDocumentRequest) SourceLang(sourceLang SourceLanguage) ApiTranslateDocumentRequest {
	r.sourceLang = &sourceLang
	return r
}

// The name of the uploaded file. Can be used as an alternative to including the file name in the file part&#39;s content disposition.
func (r ApiTranslateDocumentRequest) Filename(filename string) ApiTranslateDocumentRequest {
	r.filename = &filename
	return r
}

func (r ApiTranslateDocumentRequest) Formality(formality Formality) ApiTranslateDocumentRequest {
	r.formality = &formality
	return r
}

// A unique ID assigned to a glossary.
func (r ApiTranslateDocumentRequest) GlossaryId(glossaryId string) ApiTranslateDocumentRequest {
	r.glossaryId = &glossaryId
	return r
}

func (r ApiTranslateDocumentRequest) Execute() (*TranslateDocument200Response, *http.Response, error) {
	return r.ApiService.TranslateDocumentExecute(r)
}

/*
TranslateDocument Upload and Translate a Document

This call uploads a document and queues it for translation.
The call returns once the upload is complete, returning a document ID and key which can be used to
[query the translation status](https://www.deepl.com/docs-api/documents/get-document-status)
and to [download the translated document](https://www.deepl.com/docs-api/documents/download-document) once translation is complete.



Because the request includes a file upload, it must be an HTTP POST request with content type `multipart/form-data`.


Please be aware that the uploaded document is automatically removed from the server once the translated document has been downloaded.
You have to upload the document again in order to restart the translation.


The maximum upload limit for any document is 10 MiB and 1.000.000 characters.


You may specify the glossary to use for the document translation using the `glossary_id` parameter.
**Important:** This requires the `source_lang` parameter to be set and the language pair of the glossary has to match the language pair of the request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateDocumentRequest
*/
func (a *TranslatingDocumentsApiService) TranslateDocument(ctx context.Context) ApiTranslateDocumentRequest {
	return ApiTranslateDocumentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TranslateDocument200Response
func (a *TranslatingDocumentsApiService) TranslateDocumentExecute(r ApiTranslateDocumentRequest) (*TranslateDocument200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TranslateDocument200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslatingDocumentsApiService.TranslateDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/document"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.targetLang == nil {
		return localVarReturnValue, nil, reportError("targetLang is required and must be specified")
	}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.sourceLang != nil {
		localVarFormParams.Add("source_lang", parameterToString(*r.sourceLang, ""))
	}
	localVarFormParams.Add("target_lang", parameterToString(*r.targetLang, ""))
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"

	fileLocalVarFile := *r.file
	if fileLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(fileLocalVarFile)
		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	if r.filename != nil {
		localVarFormParams.Add("filename", parameterToString(*r.filename, ""))
	}
	if r.formality != nil {
		localVarFormParams.Add("formality", parameterToString(*r.formality, ""))
	}
	if r.glossaryId != nil {
		localVarFormParams.Add("glossary_id", parameterToString(*r.glossaryId, ""))
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["auth_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
