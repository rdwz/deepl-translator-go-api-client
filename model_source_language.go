/*
DeepL API

The DeepL API provides programmatic access to DeepLâ€™s machine translation technology.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// SourceLanguage Language of the text to be translated. Options currently available:  * `BG` - Bulgarian  * `CS` - Czech  * `DA` - Danish  * `DE` - German  * `EL` - Greek  * `EN` - English  * `ES` - Spanish  * `ET` - Estonian  * `FI` - Finnish  * `FR` - French  * `HU` - Hungarian  * `ID` - Indonesian  * `IT` - Italian  * `JA` - Japanese  * `LT` - Lithuanian  * `LV` - Latvian  * `NL` - Dutch  * `PL` - Polish  * `PT` - Portuguese (all Portuguese varieties mixed)  * `RO` - Romanian  * `RU` - Russian  * `SK` - Slovak  * `SL` - Slovenian  * `SV` - Swedish  * `TR` - Turkish  * `ZH` - Chinese  If this parameter is omitted, the API will attempt to detect the language of the text and translate it.
type SourceLanguage string

// List of SourceLanguage
const (
	BG SourceLanguage = "BG"
	CS SourceLanguage = "CS"
	DA SourceLanguage = "DA"
	DE SourceLanguage = "DE"
	EL SourceLanguage = "EL"
	EN SourceLanguage = "EN"
	ES SourceLanguage = "ES"
	ET SourceLanguage = "ET"
	FI SourceLanguage = "FI"
	FR SourceLanguage = "FR"
	HU SourceLanguage = "HU"
	ID SourceLanguage = "ID"
	IT SourceLanguage = "IT"
	JA SourceLanguage = "JA"
	LT SourceLanguage = "LT"
	LV SourceLanguage = "LV"
	NL SourceLanguage = "NL"
	PL SourceLanguage = "PL"
	PT SourceLanguage = "PT"
	RO SourceLanguage = "RO"
	RU SourceLanguage = "RU"
	SK SourceLanguage = "SK"
	SL SourceLanguage = "SL"
	SV SourceLanguage = "SV"
	TR SourceLanguage = "TR"
	ZH SourceLanguage = "ZH"
)

// All allowed values of SourceLanguage enum
var AllowedSourceLanguageEnumValues = []SourceLanguage{
	"BG",
	"CS",
	"DA",
	"DE",
	"EL",
	"EN",
	"ES",
	"ET",
	"FI",
	"FR",
	"HU",
	"ID",
	"IT",
	"JA",
	"LT",
	"LV",
	"NL",
	"PL",
	"PT",
	"RO",
	"RU",
	"SK",
	"SL",
	"SV",
	"TR",
	"ZH",
}

func (v *SourceLanguage) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := SourceLanguage(value)
	for _, existing := range AllowedSourceLanguageEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid SourceLanguage", value)
}

// NewSourceLanguageFromValue returns a pointer to a valid SourceLanguage
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewSourceLanguageFromValue(v string) (*SourceLanguage, error) {
	ev := SourceLanguage(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for SourceLanguage: valid values are %v", v, AllowedSourceLanguageEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v SourceLanguage) IsValid() bool {
	for _, existing := range AllowedSourceLanguageEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to SourceLanguage value
func (v SourceLanguage) Ptr() *SourceLanguage {
	return &v
}

type NullableSourceLanguage struct {
	value *SourceLanguage
	isSet bool
}

func (v NullableSourceLanguage) Get() *SourceLanguage {
	return v.value
}

func (v *NullableSourceLanguage) Set(val *SourceLanguage) {
	v.value = val
	v.isSet = true
}

func (v NullableSourceLanguage) IsSet() bool {
	return v.isSet
}

func (v *NullableSourceLanguage) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableSourceLanguage(val *SourceLanguage) *NullableSourceLanguage {
	return &NullableSourceLanguage{value: val, isSet: true}
}

func (v NullableSourceLanguage) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableSourceLanguage) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

